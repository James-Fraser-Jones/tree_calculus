import tactic

namespace natree

  --inductive structure of pre-trees (natural trees pre-quotienting)
  inductive pre 
  | node : pre
  | app : pre ‚Üí pre ‚Üí pre

  namespace pre

    notation `ùïã'` := pre
    notation `‚ñ¢` := pre.node
    infixl `‚ó¶`:60 := pre.app

    --reduction rules of tree calculus, specified as an inductive binary relation on pre-trees
    inductive reduces_to : ùïã' ‚Üí ùïã' ‚Üí Prop
    | kernel         (y) {z} : reduces_to (‚ñ¢‚ó¶   ‚ñ¢   ‚ó¶y‚ó¶z) y
    |   stem     (x) (y) (z) : reduces_to (‚ñ¢‚ó¶ (‚ñ¢‚ó¶x) ‚ó¶y‚ó¶z) (y‚ó¶z‚ó¶(x‚ó¶z))
    |   fork (w) (x) {y} (z) : reduces_to (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) (z‚ó¶w‚ó¶x)
    |   left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} (h : reduces_to a‚ÇÅ b‚ÇÅ) : reduces_to (a‚ÇÅ ‚ó¶ a‚ÇÇ) (b‚ÇÅ ‚ó¶ a‚ÇÇ)
    |  right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} (h : reduces_to a‚ÇÇ b‚ÇÇ) : reduces_to (a‚ÇÅ ‚ó¶ a‚ÇÇ) (a‚ÇÅ ‚ó¶ b‚ÇÇ)
    infixr ` ‚Ü¶ `:60 := reduces_to

    --equivalence relation on pre-trees generated by reflexive, symmetric, transitive closure of (‚Ü¶)
    instance equiv : setoid ùïã' := eqv_gen.setoid (‚Ü¶)

    namespace equiv

      lemma lift_reduces_to {a b} : a ‚Ü¶ b ‚Üí a ‚âà b :=
      begin
        intro h,
        apply eqv_gen.rel,
        assumption,
      end

      theorem kernel {y z} : (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) ‚âà y :=
      begin
        apply lift_reduces_to,
        apply reduces_to.kernel,
      end

      theorem stem {x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶x)‚ó¶y‚ó¶z) ‚âà (y‚ó¶z‚ó¶(x‚ó¶z)) :=
      begin
        apply lift_reduces_to,
        apply reduces_to.stem,
      end

      theorem fork {w x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) ‚âà (z‚ó¶w‚ó¶x) :=
      begin
        apply lift_reduces_to,
        apply reduces_to.fork,
      end

      lemma congr_left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶a‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces_to.left,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      lemma congr_right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} : a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà a‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces_to.right,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      theorem congr {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intros h‚ÇÅ h‚ÇÇ,
        apply eqv_gen.trans,
            apply congr_left,
            assumption,
        apply congr_right,
        assumption,
      end

      --‚ñ≥‚¨ù(‚ñ≥‚¨ùx)‚¨ùy‚¨ùz = y‚¨ùz‚¨ù(x‚¨ùz)
      --‚ñ≥‚¨ù(‚ñ≥‚¨ù‚ñ≥)‚¨ù‚ñ≥‚¨ù‚ñ≥ = ‚ñ≥‚¨ù‚ñ≥‚¨ù(‚ñ≥‚¨ù‚ñ≥)
      --(‚ñ≥‚¨ù(‚ñ≥‚¨ù‚ñ≥)‚¨ù‚ñ≥)‚¨ù‚ñ≥ = (‚ñ≥‚¨ù‚ñ≥)‚¨ù(‚ñ≥‚¨ù‚ñ≥)
      --a‚ÇÅ‚¨ùa‚ÇÇ = b‚ÇÅ‚¨ùb‚ÇÇ ‚Üí a‚ÇÅ = b‚ÇÅ ‚àß a‚ÇÇ = b‚ÇÇ
      --(‚ñ≥‚¨ù(‚ñ≥‚¨ù‚ñ≥)‚¨ù‚ñ≥) = (‚ñ≥‚¨ù‚ñ≥)
      --‚ñ≥ = (‚ñ≥‚¨ù‚ñ≥)
      ----------------------------------
      --‚ñ≥‚¨ù(‚ñ≥‚¨ù‚ñ≥)‚¨ù‚ñ≥ = ‚ñ≥‚¨ù‚ñ≥
      --‚ñ≥ = ‚ñ≥‚¨ù‚ñ≥
      --hence this is *false*
      #check @app.inj
      --(‚ó¶) is not injective modulo equivalence
      theorem not_inj {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} : a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ ‚Üí ¬¨ (a‚ÇÅ ‚âà b‚ÇÅ ‚àß a‚ÇÇ ‚âà b‚ÇÇ) :=
      begin
        sorry
      end

    end equiv

  end pre

end natree