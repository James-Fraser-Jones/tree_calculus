import tactic

namespace natree

  --inductive structure of pre-trees (natural trees pre-quotienting)
  inductive pre 
  | node : pre
  | app : pre ‚Üí pre ‚Üí pre
  | ref : char ‚Üí pre

  namespace pre

    notation `ùïã'` := pre
    notation `‚ñ¢` := node
    infixl `‚ó¶`:60 := app
    prefix `#`:60 := ref

    --reduction rules of tree calculus, specified as an inductive binary relation on pre-trees
    inductive reduces : ùïã' ‚Üí ùïã' ‚Üí Prop
    | kernel         (y) {z} : reduces (‚ñ¢‚ó¶   ‚ñ¢   ‚ó¶y‚ó¶z) y
    |   stem     (x) (y) (z) : reduces (‚ñ¢‚ó¶ (‚ñ¢‚ó¶x) ‚ó¶y‚ó¶z) (y‚ó¶z‚ó¶(x‚ó¶z))
    |   fork (w) (x) {y} (z) : reduces (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) (z‚ó¶w‚ó¶x)
    |   left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} (h : reduces a‚ÇÅ b‚ÇÅ) : reduces (a‚ÇÅ‚ó¶a‚ÇÇ) (b‚ÇÅ‚ó¶a‚ÇÇ)
    |  right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} (h : reduces a‚ÇÇ b‚ÇÇ) : reduces (a‚ÇÅ‚ó¶a‚ÇÇ) (a‚ÇÅ‚ó¶b‚ÇÇ)
    infixr ` ‚Ü¶ `:60 := reduces

    --equivalence relation on pre-trees generated by reflexive, symmetric, transitive closure of (‚Ü¶)
    instance equiv : setoid ùïã' := eqv_gen.setoid (‚Ü¶)

    namespace equiv

      lemma lift_reduces_to {a b} : a ‚Ü¶ b ‚Üí a ‚âà b :=
      begin
        intro h,
        apply eqv_gen.rel,
        assumption,
      end

      theorem kernel {y z} : (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) ‚âà y :=
      begin
        apply lift_reduces_to,
        apply reduces.kernel,
      end

      theorem stem {x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶x)‚ó¶y‚ó¶z) ‚âà (y‚ó¶z‚ó¶(x‚ó¶z)) :=
      begin
        apply lift_reduces_to,
        apply reduces.stem,
      end

      theorem fork {w x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) ‚âà (z‚ó¶w‚ó¶x) :=
      begin
        apply lift_reduces_to,
        apply reduces.fork,
      end

      lemma congr_left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶a‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces.left,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      lemma congr_right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} : a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà a‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces.right,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      theorem congr {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intros h‚ÇÅ h‚ÇÇ,
        apply eqv_gen.trans,
            apply congr_left,
            assumption,
        apply congr_right,
        assumption,
      end

    end equiv

  end pre

end natree