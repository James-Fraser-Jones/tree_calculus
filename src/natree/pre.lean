import tactic

namespace natree

  --@[derive decidable_eq]
  --inductive structure of pre-trees (natural trees pre-quotienting)
  inductive pre 
  | node : pre
  | app : pre ‚Üí pre ‚Üí pre

  namespace pre

    notation `ùïã'` := pre
    notation `‚ñ¢` := pre.node
    infixl `‚ó¶`:60 := pre.app

    instance decide_eq : decidable_eq ùïã' --this is actually derivable
    | ‚ñ¢ ‚ñ¢ := decidable.is_true rfl
    | (a‚ÇÅ‚ó¶a‚ÇÇ) (b‚ÇÅ‚ó¶b‚ÇÇ) := begin
      cases @decide_eq a‚ÇÅ b‚ÇÅ with h‚ÇÅ,
        cases @decide_eq a‚ÇÇ b‚ÇÇ with h‚ÇÇ,
          repeat {
            left,
            intro h,
            have h‚ÇÉ := app.inj h,
            cases h‚ÇÉ,
            apply h‚ÇÅ,
            assumption,
          },
      cases @decide_eq a‚ÇÇ b‚ÇÇ with h‚ÇÇ,
        left,
        intro h,
        have h‚ÇÉ := app.inj h,
        cases h‚ÇÉ,
        apply h‚ÇÇ,
        assumption,
      right,
      apply congr_arg2,
      repeat {assumption},
    end
    | ‚ñ¢ (b‚ÇÅ‚ó¶b‚ÇÇ) := begin
      left,
      intro h,
      cases h,
    end
    | (a‚ÇÅ‚ó¶a‚ÇÇ) ‚ñ¢ := begin
      left,
      intro h,
      cases h,
    end

    --reduction rules of tree calculus, specified as an inductive binary relation on pre-trees
    --should this actually be type instead???
    --https://discord.com/channels/679792285910827018/707609591940382830/894343635397652500
    inductive reduces : ùïã' ‚Üí ùïã' ‚Üí Prop
    | kernel         (y) {z} : reduces (‚ñ¢‚ó¶   ‚ñ¢   ‚ó¶y‚ó¶z) y
    |   stem     (x) (y) (z) : reduces (‚ñ¢‚ó¶ (‚ñ¢‚ó¶x) ‚ó¶y‚ó¶z) (y‚ó¶z‚ó¶(x‚ó¶z))
    |   fork (w) (x) {y} (z) : reduces (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) (z‚ó¶w‚ó¶x)
    |   left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} (h : reduces a‚ÇÅ b‚ÇÅ) : reduces (a‚ÇÅ ‚ó¶ a‚ÇÇ) (b‚ÇÅ ‚ó¶ a‚ÇÇ)
    |  right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} (h : reduces a‚ÇÇ b‚ÇÇ) : reduces (a‚ÇÅ ‚ó¶ a‚ÇÇ) (a‚ÇÅ ‚ó¶ b‚ÇÇ)
    infixr ` ‚Ü¶ `:60 := reduces

    #check @inhabited
    #check @nonempty

    -----------------------------------------------------------------------------------

    lemma decide_iff (a) : a ‚Ü¶ ‚ñ¢ ‚Üî ‚àÉ z, a = (‚ñ¢‚ó¶‚ñ¢‚ó¶‚ñ¢‚ó¶z) := begin 
      split,
        intro h,
        cases h,
        apply exists.intro,
        refl,
      intro h,
      cases h,
      rw h_h,
      apply reduces.kernel,
    end

    def decide_reduces_to : decidable_rel (‚Ü¶)
    | (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) y‚ÇÇ := begin
      sorry
    end
    | (‚ñ¢‚ó¶(‚ñ¢‚ó¶x)‚ó¶y‚ó¶z) (y‚ÇÇ‚ó¶z‚ÇÇ‚ó¶(x‚ÇÇ‚ó¶z‚ÇÉ)) := begin
      sorry
    end
    | (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) (z‚ÇÇ‚ó¶w‚ÇÇ‚ó¶x‚ÇÇ) := begin
      sorry --works when w = w‚ÇÇ ...
    end
    | (a‚ÇÅ‚ó¶a‚ÇÇ) (b‚ÇÅ‚ó¶b‚ÇÇ) := 
    if h : a‚ÇÅ = b‚ÇÅ then 
    begin 
      rw h,
      cases decide_reduces_to a‚ÇÇ b‚ÇÇ with h‚ÇÇ h‚ÇÇ,
        left,
        intro h‚ÇÉ,
        sorry,
      sorry,
    end 
    else if a‚ÇÇ = b‚ÇÇ then 
    sorry 
    else 
    sorry
    | a ‚ñ¢ :=
    begin
      cases a with a a‚ÇÑ,
        left, intro h, cases h,
      cases a with a a‚ÇÉ,
        left, intro h, cases h,
      cases a with a‚ÇÅ a‚ÇÇ,
        left, intro h, cases h,
      by_cases h‚ÇÅ : a‚ÇÅ = ‚ñ¢,
        by_cases h‚ÇÇ : a‚ÇÇ = ‚ñ¢,
          by_cases h‚ÇÉ : a‚ÇÉ = ‚ñ¢,
            right, rw [h‚ÇÅ, h‚ÇÇ, h‚ÇÉ], apply reduces.kernel,
          left, intro h, apply h‚ÇÉ, cases h, refl,
        left, intro h, apply h‚ÇÇ, cases h, refl,
      left, intro h, apply h‚ÇÅ, cases h, refl,
    end
    | ‚ñ¢ b := begin
      left,
      intro h,
      cases h,
    end

    -----------------------------------------------------------------------------------

    --equivalence relation on pre-trees generated by reflexive, symmetric, transitive closure of (‚Ü¶)
    instance equiv : setoid ùïã' := eqv_gen.setoid (‚Ü¶)

    namespace equiv

      lemma lift_reduces_to {a b} : a ‚Ü¶ b ‚Üí a ‚âà b :=
      begin
        intro h,
        apply eqv_gen.rel,
        assumption,
      end

      theorem kernel {y z} : (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) ‚âà y :=
      begin
        apply lift_reduces_to,
        apply reduces.kernel,
      end

      theorem stem {x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶x)‚ó¶y‚ó¶z) ‚âà (y‚ó¶z‚ó¶(x‚ó¶z)) :=
      begin
        apply lift_reduces_to,
        apply reduces.stem,
      end

      theorem fork {w x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) ‚âà (z‚ó¶w‚ó¶x) :=
      begin
        apply lift_reduces_to,
        apply reduces.fork,
      end

      lemma congr_left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶a‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces.left,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      lemma congr_right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} : a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà a‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces.right,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      theorem congr {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intros h‚ÇÅ h‚ÇÇ,
        apply eqv_gen.trans,
            apply congr_left,
            assumption,
        apply congr_right,
        assumption,
      end

      -----------------------------------------------------------------------------------

      --I believe this requires confluence to prove in the transitive case
      lemma hmm : ¬¨ ‚ñ¢ ‚âà ‚ñ¢‚ó¶‚ñ¢ := begin
        sorry
      end

      --(‚ó¶) is *not* injective modulo equivalence
      theorem not_inj : ¬¨ (‚àÄ {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ}, a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ ‚Üí a‚ÇÅ ‚âà b‚ÇÅ ‚àß a‚ÇÇ ‚âà b‚ÇÇ) :=
      begin
        intro h‚ÇÅ,
        have h‚ÇÇ := @stem ‚ñ¢ ‚ñ¢ ‚ñ¢,
        have h‚ÇÉ := @h‚ÇÅ (‚ñ¢‚ó¶(‚ñ¢‚ó¶‚ñ¢)‚ó¶‚ñ¢) ‚ñ¢ (‚ñ¢‚ó¶‚ñ¢) (‚ñ¢‚ó¶‚ñ¢),
        have h‚ÇÑ := h‚ÇÉ h‚ÇÇ,
        cases h‚ÇÑ,
        apply hmm,
        assumption,
      end

      -----------------------------------------------------------------------------------

    end equiv

  end pre

end natree