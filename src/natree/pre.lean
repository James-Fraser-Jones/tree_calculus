import tactic

namespace natree

  --inductive structure of pre-trees (natural trees pre-quotienting)
  inductive pre 
  | node : pre
  | app : pre ‚Üí pre ‚Üí pre

  #print prefix natree.pre --show all generated defs for "pre"

  namespace pre

    notation `ùïã'` := pre
    notation `‚ñ¢` := pre.node
    infixl `‚ó¶`:60 := pre.app

    --reduction rules of tree calculus, specified as an inductive binary relation on pre-trees
    inductive reduces_to : ùïã' ‚Üí ùïã' ‚Üí Prop
    | kernel         (y) {z} : reduces_to (‚ñ¢‚ó¶   ‚ñ¢   ‚ó¶y‚ó¶z) y
    |   stem     (x) (y) (z) : reduces_to (‚ñ¢‚ó¶ (‚ñ¢‚ó¶x) ‚ó¶y‚ó¶z) (y‚ó¶z‚ó¶(x‚ó¶z))
    |   fork (w) (x) {y} (z) : reduces_to (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) (z‚ó¶w‚ó¶x)
    |   left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} (h : reduces_to a‚ÇÅ b‚ÇÅ) : reduces_to (a‚ÇÅ ‚ó¶ a‚ÇÇ) (b‚ÇÅ ‚ó¶ a‚ÇÇ)
    |  right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} (h : reduces_to a‚ÇÇ b‚ÇÇ) : reduces_to (a‚ÇÅ ‚ó¶ a‚ÇÇ) (a‚ÇÅ ‚ó¶ b‚ÇÇ)
    infixr ` ‚Ü¶ `:60 := reduces_to

    -----------------------------------------------------------------------------------

    --https://xenaproject.wordpress.com/2018/03/24/no-confusion-over-no_confusion/
    #check @pre.no_confusion --what dis? https://leanprover.github.io/theorem_proving_in_lean/induction_and_recursion.html?highlight=no_confusion
    #check @pre.no_confusion_type
    
    lemma how : ¬¨ ‚ñ¢ ‚Ü¶ ‚ñ¢ := begin --how does this work?
      intro h,
      cases h,
    end
    #print how

    #reduce @decidable_rel
    def decide_reduces_to (a b) : decidable (a ‚Ü¶ b)
    | (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) (y‚ÇÇ) := if y = y‚ÇÇ then decidable.is_true (reduces_to.kernel a) else decidable.is_false (reduces_to.kernel a)

    -----------------------------------------------------------------------------------

    --equivalence relation on pre-trees generated by reflexive, symmetric, transitive closure of (‚Ü¶)
    instance equiv : setoid ùïã' := eqv_gen.setoid (‚Ü¶)

    namespace equiv

      lemma lift_reduces_to {a b} : a ‚Ü¶ b ‚Üí a ‚âà b :=
      begin
        intro h,
        apply eqv_gen.rel,
        assumption,
      end

      theorem kernel {y z} : (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) ‚âà y :=
      begin
        apply lift_reduces_to,
        apply reduces_to.kernel,
      end

      theorem stem {x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶x)‚ó¶y‚ó¶z) ‚âà (y‚ó¶z‚ó¶(x‚ó¶z)) :=
      begin
        apply lift_reduces_to,
        apply reduces_to.stem,
      end

      theorem fork {w x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) ‚âà (z‚ó¶w‚ó¶x) :=
      begin
        apply lift_reduces_to,
        apply reduces_to.fork,
      end

      lemma congr_left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶a‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces_to.left,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      lemma congr_right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} : a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà a‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intro h,
        induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
              apply eqv_gen.rel,
              apply reduces_to.right,
              assumption,
            apply eqv_gen.refl,
          apply eqv_gen.symm,
          assumption,
        apply eqv_gen.trans,
            assumption,
        assumption,
      end

      theorem congr {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ :=
      begin
        intros h‚ÇÅ h‚ÇÇ,
        apply eqv_gen.trans,
            apply congr_left,
            assumption,
        apply congr_right,
        assumption,
      end

      -----------------------------------------------------------------------------------

      --(‚ó¶) is not injective modulo equivalence
      theorem not_inj : ¬¨ (‚àÄ {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ}, a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ ‚Üí a‚ÇÅ ‚âà b‚ÇÅ ‚àß a‚ÇÇ ‚âà b‚ÇÇ) :=
      begin
        intro h‚ÇÅ,
        have h‚ÇÇ := @stem ‚ñ¢ ‚ñ¢ ‚ñ¢,
        have h‚ÇÉ := @h‚ÇÅ (‚ñ¢‚ó¶(‚ñ¢‚ó¶‚ñ¢)‚ó¶‚ñ¢) ‚ñ¢ (‚ñ¢‚ó¶‚ñ¢) (‚ñ¢‚ó¶‚ñ¢),
        have h‚ÇÑ := h‚ÇÉ h‚ÇÇ,
        cases h‚ÇÑ,
        --need reducability and equivalence to have decidable instances (then it'll be much easier)
        --actually equivalence is almost certainly *not* decidable in general
      end

      #reduce to_bool (‚ñ¢ ‚Ü¶ ‚ñ¢‚ó¶‚ñ¢)
      #check @app.inj

      -----------------------------------------------------------------------------------

    end equiv

  end pre

end natree