import tactic

inductive natree' 
  | node : natree'
  | app : natree' ‚Üí natree' ‚Üí natree'

namespace natree'

  notation `ùïã'` := natree'
  notation `‚ñ¢` := natree'.node
  infixl `‚ó¶`:60 := natree'.app

  --reduction rules of tree calculus, specified as an inductive binary relation on natural trees
  inductive reduces_to : ùïã' ‚Üí ùïã' ‚Üí Prop
  | kernel         (y) {z} : reduces_to (‚ñ¢‚ó¶   ‚ñ¢   ‚ó¶y‚ó¶z) y
  |   stem     (x) (y) (z) : reduces_to (‚ñ¢‚ó¶ (‚ñ¢‚ó¶x) ‚ó¶y‚ó¶z) (y‚ó¶z‚ó¶(x‚ó¶z))
  |   fork (w) (x) {y} (z) : reduces_to (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) (z‚ó¶w‚ó¶x)
  |   left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} (h : reduces_to a‚ÇÅ b‚ÇÅ) : reduces_to (a‚ÇÅ ‚ó¶ a‚ÇÇ) (b‚ÇÅ ‚ó¶ a‚ÇÇ)
  |  right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} (h : reduces_to a‚ÇÇ b‚ÇÇ) : reduces_to (a‚ÇÅ ‚ó¶ a‚ÇÇ) (a‚ÇÅ ‚ó¶ b‚ÇÇ)
  infixr ` ‚Ü¶ `:60 := reduces_to

  --equivalence relation on natural generated by reflexive, symmetric, transitive closure of (‚Ü¶)
  instance equiv_to : setoid ùïã' := eqv_gen.setoid (‚Ü¶)

  namespace equiv_to

    lemma lift_reduces_to {a b} : a ‚Ü¶ b ‚Üí a ‚âà b :=
    begin
      intro h,
      apply eqv_gen.rel,
      assumption,
    end

    theorem kernel {y z} : (‚ñ¢‚ó¶‚ñ¢‚ó¶y‚ó¶z) ‚âà y :=
    begin
      apply lift_reduces_to,
      apply reduces_to.kernel,
    end

    theorem stem {x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶x)‚ó¶y‚ó¶z) ‚âà (y‚ó¶z‚ó¶(x‚ó¶z)) :=
    begin
      apply lift_reduces_to,
      apply reduces_to.stem,
    end

    theorem fork {w x y z} : (‚ñ¢‚ó¶(‚ñ¢‚ó¶w‚ó¶x)‚ó¶y‚ó¶z) ‚âà (z‚ó¶w‚ó¶x) :=
    begin
      apply lift_reduces_to,
      apply reduces_to.fork,
    end

    lemma congr_left {a‚ÇÅ a‚ÇÇ b‚ÇÅ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶a‚ÇÇ :=
    begin
      intro h,
      induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
            apply eqv_gen.rel,
            apply reduces_to.left,
            assumption,
          apply eqv_gen.refl,
        apply eqv_gen.symm,
        assumption,
      apply eqv_gen.trans,
          assumption,
      assumption,
    end

    lemma congr_right {a‚ÇÅ a‚ÇÇ b‚ÇÇ} : a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà a‚ÇÅ‚ó¶b‚ÇÇ :=
    begin
      intro h,
      induction h with x y h _ x y h‚ÇÅ h‚ÇÇ x y z h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ,
            apply eqv_gen.rel,
            apply reduces_to.right,
            assumption,
          apply eqv_gen.refl,
        apply eqv_gen.symm,
        assumption,
      apply eqv_gen.trans,
          assumption,
      assumption,
    end

    theorem congr {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} : a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÇ ‚âà b‚ÇÇ ‚Üí a‚ÇÅ‚ó¶a‚ÇÇ ‚âà b‚ÇÅ‚ó¶b‚ÇÇ :=
    begin
      intros h‚ÇÅ h‚ÇÇ,
      apply eqv_gen.trans,
          apply congr_left,
          assumption,
      apply congr_right,
      assumption,
    end

  end equiv_to

end natree'

def natree := quotient natree'.equiv_to

namespace natree

  notation `ùïã` := natree
  
  def node : ùïã := ‚ü¶‚ñ¢‚üß
  notation `‚ñ≥` := node

  def app' (t‚ÇÅ t‚ÇÇ) := ‚ü¶t‚ÇÅ ‚ó¶ t‚ÇÇ‚üß
  lemma app'_liftable {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ} (h‚ÇÅ : a‚ÇÅ ‚âà b‚ÇÅ) (h‚ÇÇ : a‚ÇÇ ‚âà b‚ÇÇ) : app' a‚ÇÅ a‚ÇÇ = app' b‚ÇÅ b‚ÇÇ :=
  begin
    repeat {rw wrapp},
    apply quotient.sound,
    apply natree'.equiv_to.congr,
    repeat {assumption}
  end 

  def app : ùïã ‚Üí ùïã ‚Üí ùïã := quotient.lift‚ÇÇ app' @app'_liftable
  infixl `‚¨ù`:60 := app

  theorem quot_dist_app {a b} : ‚ü¶a ‚ó¶ b‚üß = ‚ü¶a‚üß ‚¨ù ‚ü¶b‚üß := rfl

  @[simp] theorem kernel {y z} : ‚ñ≥‚¨ù‚ñ≥‚¨ùy‚¨ùz = y :=
  begin
    have h‚ÇÅ := quotient.exists_rep y, cases h‚ÇÅ with y' h‚ÇÅ, rw ‚Üêh‚ÇÅ,
    have h‚ÇÇ := quotient.exists_rep z, cases h‚ÇÇ with z' h‚ÇÇ, rw ‚Üêh‚ÇÇ,
    rw node,
    repeat {rw ‚Üêquot_dist_app},
    apply quotient.sound,
    apply natree'.equiv_to.kernel,
  end

  @[simp] theorem stem {x y z} : ‚ñ≥‚¨ù(‚ñ≥‚¨ùx)‚¨ùy‚¨ùz = y‚¨ùz‚¨ù(x‚¨ùz) :=
  begin
    have h‚ÇÅ := quotient.exists_rep x, cases h‚ÇÅ with x' h‚ÇÅ, rw ‚Üêh‚ÇÅ,
    have h‚ÇÇ := quotient.exists_rep y, cases h‚ÇÇ with y' h‚ÇÇ, rw ‚Üêh‚ÇÇ,
    have h‚ÇÉ := quotient.exists_rep z, cases h‚ÇÉ with z' h‚ÇÉ, rw ‚Üêh‚ÇÉ,
    rw node,
    repeat {rw ‚Üêquot_dist_app},
    apply quotient.sound,
    apply natree'.equiv_to.stem,
  end

  @[simp] theorem fork {w x y z} : ‚ñ≥‚¨ù(‚ñ≥‚¨ùw‚¨ùx)‚¨ùy‚¨ùz = z‚¨ùw‚¨ùx :=
  begin
    have h‚ÇÅ := quotient.exists_rep w, cases h‚ÇÅ with w' h‚ÇÅ, rw ‚Üêh‚ÇÅ,
    have h‚ÇÇ := quotient.exists_rep x, cases h‚ÇÇ with x' h‚ÇÇ, rw ‚Üêh‚ÇÇ,
    have h‚ÇÉ := quotient.exists_rep y, cases h‚ÇÉ with y' h‚ÇÉ, rw ‚Üêh‚ÇÉ,
    have h‚ÇÑ := quotient.exists_rep z, cases h‚ÇÑ with z' h‚ÇÑ, rw ‚Üêh‚ÇÑ,
    rw node,
    repeat {rw ‚Üêquot_dist_app},
    apply quotient.sound,
    apply natree'.equiv_to.fork,
  end

end natree